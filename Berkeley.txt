Berkeley.java ->
import java.util.*;

class Node {
    final int id;
    int hours;
    int minutes;
    boolean alive = true;

    Node(int id, int hours, int minutes) {
        this.id = id;
        this.hours = hours;
        this.minutes = minutes;
    }

    // Convert node time to total minutes (0-1439)
    int timeInMinutes() {
        return hours * 60 + minutes;
    }

    // Update node time from total minutes
    void setTimeFromMinutes(int totalMinutes) {
        totalMinutes = (totalMinutes + 1440) % 1440; // ensure 0-1439
        hours = totalMinutes / 60;
        minutes = totalMinutes % 60;
    }

    String formattedTime() {
        return String.format("%02d:%02d", hours, minutes);
    }
}

public class Berkeley {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of nodes: ");
        int n = sc.nextInt();
        sc.nextLine();

        List<Node> nodes = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            System.out.print("Enter time for Node " + i + " (HH:MM): ");
            String input = sc.nextLine();
            String[] parts = input.split(":");
            int h = Integer.parseInt(parts[0]);
            int m = Integer.parseInt(parts[1]);
            nodes.add(new Node(i, h, m));
        }

        // Show times before sync
        System.out.println("\nBefore sync:");
        for (Node node : nodes) {
            System.out.println("Node " + node.id + ": " + node.formattedTime());
        }

        // Convert all times to minutes
        List<Integer> times = new ArrayList<>();
        for (Node node : nodes) {
            times.add(node.timeInMinutes());
        }

        // --- Remove extreme outliers (trim 10% top/bottom) ---
        Collections.sort(times);
        int trimCount = Math.max(1, times.size() / 10); // at least 1
        List<Integer> trimmedTimes = times.subList(trimCount, times.size() - trimCount);

        // Circular averaging of trimmed times
        double sumSin = 0;
        double sumCos = 0;
        for (int t : trimmedTimes) {
            double angle = 2 * Math.PI * t / 1440.0;
            sumSin += Math.sin(angle);
            sumCos += Math.cos(angle);
        }
        double avgAngle = Math.atan2(sumSin / trimmedTimes.size(), sumCos / trimmedTimes.size());
        if (avgAngle < 0) avgAngle += 2 * Math.PI;
        int avgMinutes = (int) Math.round(avgAngle * 1440 / (2 * Math.PI)) % 1440;

        // Adjust all nodes to average
        for (Node node : nodes) {
            node.setTimeFromMinutes(avgMinutes);
        }

        // Show times after sync
        System.out.println("\nAfter sync:");
        for (Node node : nodes) {
            System.out.println("Node " + node.id + ": " + node.formattedTime());
        }

        sc.close();
    }
}
